% ==== Image Addition and Subtraction WITHOUT Built-in Arithmetic ====

% Step 1: ‡¶õ‡¶¨‡¶ø ‡¶™‡ßú‡¶æ
img1 = imread('img1.jpg');
img2 = imread('img2.jpg');

% Step 2: ‡¶∏‡¶æ‡¶á‡¶ú ‡¶è‡¶ï ‡¶ï‡¶∞‡¶æ
img1 = imresize(img1, [256 256]);
img2 = imresize(img2, [256 256]);

% Step 3: ‡¶°‡¶æ‡¶¨‡¶≤ ‡¶ü‡¶æ‡¶á‡¶™‡ßá ‡¶ï‡¶®‡¶≠‡¶æ‡¶∞‡ßç‡¶ü
img1 = im2double(img1);
img2 = im2double(img2);

% Step 4: ‡¶á‡¶Æ‡ßá‡¶ú‡ßá‡¶∞ ‡¶∏‡¶æ‡¶á‡¶ú ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
[rows, cols, channels] = size(img1);

% Step 5: ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßç‡¶∞‡¶ø‡¶ï‡ßç‡¶∏ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ
added_img = zeros(rows, cols, channels);
subtracted_img = zeros(rows, cols, channels);

% Step 6: ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤ ‡¶¨‡¶æ‡¶á ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤ ‡¶≤‡ßÅ‡¶™ ‡¶ï‡¶∞‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ì ‡¶¨‡¶ø‡ßü‡ßã‡¶ó
for i = 1:rows
    for j = 1:cols
        for k = 1:channels
            % Addition
            val = img1(i,j,k) + img2(i,j,k);
            if val > 1
                val = 1;  % overflow ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£
            end
            added_img(i,j,k) = val;

            % Subtraction
            val = img1(i,j,k) - img2(i,j,k);
            if val < 0
                val = 0;  % underflow ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£
            end
            subtracted_img(i,j,k) = val;
        end
    end
end

% Step 7: Show all images
figure;
subplot(2,2,1); imshow(img1); title('Image 1');
subplot(2,2,2); imshow(img2); title('Image 2');
subplot(2,2,3); imshow(added_img); title('Added (Manual)');
subplot(2,2,4); imshow(subtracted_img); title('Subtracted (Manual)');

% ==== Negation of image  WITHOUT Built-in Arithmetic ====

img = imread('img1.jpg');
img = imresize(img, [256 256]);
img = im2double(img);

[rows, cols, channels] = size(img);
neg_img = zeros(rows, cols, channels);

for i = 1:rows
    for j = 1:cols
        for k = 1:channels
            neg_img(i,j,k) = 1 - img(i,j,k);   % pixel-wise negate
        end
    end
end

figure;
subplot(1,2,1); imshow(img); title('Original Image');
subplot(1,2,2); imshow(neg_img); title('Negative (Manual)');


% ==== RGB image to Gray image conversion WITHOUT Built-in Arithmetic ====

img = imread('img3.jpg');
img = imresize(img, [256 256]);
img = im2double(img); % 0-1 scale

% ==== ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ~ (tilde) ‡¶π‡¶≤‡ßã MATLAB-‡¶è‡¶∞ special symbol ‡¶Ø‡¶æ‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá:"‡¶è‡¶á ‡¶Æ‡¶æ‡¶®‡¶ü‡¶æ ‡¶Ü‡¶Æ‡¶ø ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡¶ø ‡¶®‡¶æ / ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶®‡ßá‡¶á"‡•§ ====
% ‡¶ß‡¶∞‡ßã img ‡¶è‡¶ï‡¶ü‡¶æ RGB ‡¶á‡¶Æ‡ßá‡¶ú‡•§ ‡¶§‡¶æ‡¶π‡¶≤‡ßá:size(img) ‚Üí [256 256 3] ‡¶Æ‡¶æ‡¶®‡ßá:256‡¶ü‡¶æ row 256‡¶ü‡¶æ column 3‡¶ü‡¶æ channel (Red, Green, Blue)


[rows, cols, ~] = size(img);
gray_img = zeros(rows, cols);         % 1 channel grayscale

for i = 1:rows
    for j = 1:cols
        R = img(i,j,1);
        G = img(i,j,2);
        B = img(i,j,3);
        gray_img(i,j) = 0.2989*R + 0.5870*G + 0.1140*B;
    end
end

figure;
subplot(1,2,1); imshow(img); title('Original RGB Image');
subplot(1,2,2); imshow(gray_img); title('Grayscale (Manual)');

% ==== RGB image to Binary image conversion WITHOUT Built-in Arithmetic ====

img = imread('img3.jpg');
img = imresize(img, [256 256]);
img = im2double(img);% 0 ‡¶•‡ßá‡¶ï‡ßá 1 ‡¶∏‡ßç‡¶ï‡ßá‡¶≤‡ßá ‡¶Ü‡¶®‡¶æ

%‡¶è‡¶á ‡¶≤‡¶æ‡¶á‡¶®‡¶ü‡¶æ ‡¶™‡ßÅ‡¶∞‡ßã ‡¶á‡¶Æ‡ßá‡¶ú‡ßá‡¶∞ R, G, B ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá‡¶∞ matrix ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶ó‡ßç‡¶∞‡ßá‡¶∏‡ßç‡¶ï‡ßá‡¶≤ ‡¶¨‡¶æ‡¶®‡¶æ‡ßü‡•§ 
% ‡¶ö‡¶æ‡¶á‡¶≤‡ßá loop ‡¶¶‡¶ø‡ßü‡ßá‡¶ì ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶è‡¶ü‡¶æ faster & efficient

gray_img = 0.2989*img(:,:,1) + 0.5870*img(:,:,2) + 0.1140*img(:,:,3);

% [rows, cols, ~] = size(img);
% gray_img = zeros(rows, cols);
% 
% for i = 1:rows
%     for j = 1:cols
%         R = img(i,j,1);
%         G = img(i,j,2);
%         B = img(i,j,3);
%         gray_img(i,j) = 0.2989*R + 0.5870*G + 0.1140*B;
%     end
% end

threshold = 0.5; % ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤ ‡¶•‡ßç‡¶∞‡ßá‡¶∂‡¶π‡ßã‡¶≤‡ßç‡¶° (‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü)
[rows, cols] = size(gray_img);
binary_img = zeros(rows, cols);

for i = 1:rows
    for j = 1:cols
        if gray_img(i,j) >= threshold
            binary_img(i,j) = 1;
        else
            binary_img(i,j) = 0;
        end
    end
end

figure;
subplot(1,3,1); imshow(img); title('Original RGB Image');
subplot(1,3,2); imshow(gray_img); title('Grayscale Image');
subplot(1,3,3); imshow(binary_img); title('Binary Image (Manual)');

% ==== Image zooming and shrinking WITHOUT Built-in Arithmetic ====

img = imread('img3.jpg');
img = imresize(img, [256 256]);     % ‡¶∏‡¶æ‡¶á‡¶ú ‡¶´‡¶ø‡¶ï‡ßç‡¶∏
img = rgb2gray(img);                % ‡¶∏‡¶æ‡¶¶‡¶æ‡¶ï‡¶æ‡¶≤‡ßã ‡¶ï‡¶∞‡¶õ‡¶ø, ‡¶Ø‡¶æ‡¶§‡ßá 2D ‡¶π‡ßü
img = im2double(img);               % ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤ ‡¶Æ‡¶æ‡¶®‡¶ï‡ßá 0-1 ‡¶∏‡ßç‡¶ï‡ßá‡¶≤‡ßá ‡¶Ü‡¶®‡¶õ‡¶ø

%scale = 2;% ‡¶∏‡ßç‡¶ï‡ßá‡¶≤ ‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ (Zoom in)
scale =0.5;
[rows, cols] = size(img);           % Original image size

new_rows = round(rows * scale);     % ‡¶®‡¶§‡ßÅ‡¶® image height
new_cols = round(cols * scale);     % ‡¶®‡¶§‡ßÅ‡¶® image width
scaled_img = zeros(new_rows, new_cols);  % ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶õ‡¶¨‡¶ø ‡¶¨‡¶æ‡¶®‡¶æ‡¶≤‡¶æ‡¶Æ (‡¶∏‡¶¨ ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤ 0)

for i = 1:new_rows
    for j = 1:new_cols
        % ‡¶™‡ßÅ‡¶∞‡ßã‡¶®‡ßã ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤‡ßá‡¶∞ ‡¶™‡¶ú‡¶ø‡¶∂‡¶® ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶õ‡¶ø (Nearest neighbor)
        x = round(i / scale);
        y = round(j / scale);
        
        % ‡¶Ø‡¶¶‡¶ø ‡¶™‡¶ú‡¶ø‡¶∂‡¶® 0 ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡ßü, ‡¶§‡¶æ‡¶π‡¶≤‡ßá 1 ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶ö‡ßç‡¶õ‡¶ø (index error ‡¶è‡ßú‡¶æ‡¶§‡ßá)
        if x < 1
            x = 1;
        end
        if y < 1
            y = 1;
        end
        
        % ‡¶®‡¶§‡ßÅ‡¶® ‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤ ‡¶Æ‡¶æ‡¶® = ‡¶™‡ßÅ‡¶∞‡¶æ‡¶§‡¶® ‡¶õ‡¶¨‡¶ø‡¶∞ ‡¶ï‡¶æ‡¶õ‡¶æ‡¶ï‡¶æ‡¶õ‡¶ø ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤
        scaled_img(i,j) = img(x, y);
    end
end

% ‡¶õ‡¶¨‡¶ø ‡¶¶‡ßá‡¶ñ‡¶æ‡¶ö‡ßç‡¶õ‡¶ø
figure;
subplot(1,2,1); imshow(img); title('Original Image');
subplot(1,2,2); imshow(scaled_img); title('Scaled Image (2x) - Manual');


clc;
clear;
% === Histogram of an image WITHOUT Built-in Arithmetic ====

% Step 1: Read the image (RGB)
img = imread('img3.jpg');    % ‡¶õ‡¶¨‡¶ø‡¶ü‡¶ø current folder-‡¶è ‡¶•‡¶æ‡¶ï‡¶§‡ßá ‡¶π‡¶¨‡ßá

% Step 2: Manually convert to grayscale
[rows, cols, ch] = size(img);
gray_img = zeros(rows, cols);  % ‡¶ó‡ßç‡¶∞‡ßá‡¶∏‡ßç‡¶ï‡ßá‡¶≤ ‡¶á‡¶Æ‡ßá‡¶ú ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶õ‡¶ø

for i = 1:rows
    for j = 1:cols
        R = double(img(i,j,1));
        G = double(img(i,j,2));
        B = double(img(i,j,3));
        gray_img(i,j) = 0.2989 * R + 0.5870 * G + 0.1140 * B;
    end
end

gray_img = uint8(gray_img);  % ‡¶Ü‡¶¨‡¶æ‡¶∞ 0‚Äì255 scale ‡¶è ‡¶Ü‡¶®‡¶≤‡¶æ‡¶Æ

% Step 3: Calculate histogram manually
hist_manual = zeros(1, 256);   % 256 ‡¶ò‡¶∞‡ßá‡¶∞ ‡¶π‡¶ø‡¶∏‡ßç‡¶ü‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ array

for i = 1:rows
    for j = 1:cols
        val = gray_img(i,j);           % ‡¶™‡¶ø‡¶ï‡ßç‡¶∏‡ßá‡¶≤ ‡¶Æ‡¶æ‡¶® (0‚Äì255)
        hist_manual(val+1) = hist_manual(val+1) + 1;  % ‡¶ó‡ßÅ‡¶®‡¶õ‡¶ø
    end
end

% Step 4: Display grayscale image
figure;
imshow(gray_img);
title('Grayscale Image (Manual Conversion)');

% Step 5: Display manual histogram
figure;
bar(0:255, hist_manual, 'b');   % ‡¶¨‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶∞‡ßç‡¶ü ‡¶Ü‡¶Å‡¶ï‡¶õ‡¶ø
xlabel('Intensity Value (0‚Äì255)');
ylabel('Pixel Count');
title('Manual Histogram (No Built-in Function)');


clc;
clear;

% 1. ‡¶ó‡ßç‡¶∞‡ßá‡¶∏‡ßç‡¶ï‡ßá‡¶≤ ‡¶õ‡¶¨‡¶ø ‡¶á‡¶®‡¶™‡ßÅ‡¶ü
img = imread('cameraman.tif');
[row, col] = size(img);

% 2. Histogram ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ (0-255)
hist = zeros(1,256);  % 256‡¶ü‡¶ø gray level

for i = 1:row
    for j = 1:col
        intensity = img(i,j);
        hist(intensity+1) = hist(intensity+1) + 1;  % +1 ‡¶ï‡¶æ‡¶∞‡¶£ MATLAB index 1 ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡ßü
    end
end

% 3. Probability Density Function (PDF) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
pdf = hist / (row * col);

% 4. Cumulative Distribution Function (CDF) ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
cdf = zeros(1,256);
cdf(1) = pdf(1);
for i = 2:256
    cdf(i) = cdf(i-1) + pdf(i);
end

% 5. CDF ‡¶ï‡ßá scale ‡¶ï‡¶∞‡ßá 0-255 range-‡¶è ‡¶Ü‡¶®‡¶æ (equalized mapping ‡¶§‡ßà‡¶∞‡¶ø)
eq_map = round(cdf * 255);

% 6. Equalized image ‡¶§‡ßà‡¶∞‡¶ø
equalized_img = zeros(row, col, 'uint8');
for i = 1:row
    for j = 1:col
        old_val = img(i,j);
        equalized_img(i,j) = eq_map(old_val+1);
    end
end

% 7. ‡¶õ‡¶¨‡¶ø ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã
figure;
subplot(1,2,1);
imshow(img);
title('Original Image');

subplot(1,2,2);
imshow(equalized_img);
title('Histogram Equalized Image');


%%Histogram Equalization ‡¶ï‡ßÄ?
‚Üí ‡¶è‡¶ü‡¶ø ‡¶è‡¶Æ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá image-‡¶è‡¶∞ contrast ‡¶¨‡¶æ‡ßú‡¶æ‡¶®‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø histogram ‡¶ï‡ßá ‡¶∏‡¶Æ‡¶æ‡¶®‡¶≠‡¶æ‡¶¨‡ßá ‡¶õ‡ßú‡¶ø‡ßü‡ßá ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡ßü‡•§

Histogram ‡¶ï‡¶ø‡¶∏‡ßá ‡¶¨‡ßã‡¶ù‡¶æ‡ßü?
‚Üí ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø intensity value (0-255) ‡¶ï‡¶§‡¶¨‡¶æ‡¶∞ ‡¶è‡¶∏‡ßá‡¶õ‡ßá ‡¶∏‡ßá‡¶ü‡¶ø‡¶∞ frequency distribution‡•§

CDF ‡¶ï‡ßá‡¶® ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞?
‚Üí CDF ‡¶¶‡¶ø‡ßü‡ßá‡¶á ‡¶¨‡ßÅ‡¶ù‡¶ø ‡¶ï‡ßã‡¶® intensity ‡¶ï‡¶§‡¶ü‡¶æ accumulated ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶∏‡ßá‡¶ü‡¶æ‡¶ï‡ßá‡¶á ‡¶Ü‡¶Æ‡¶∞‡¶æ mapping-‡¶è ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶ø‡•§

Image bright ‡¶π‡ßü ‡¶®‡¶æ‡¶ï‡¶ø dark?
‚Üí Image ‡¶è‡¶∞ contrast ‡¶¨‡¶æ‡ßú‡ßá‡•§ Dark area ‡¶â‡¶ú‡ßç‡¶ú‡ßç‡¶¨‡¶≤ ‡¶π‡ßü, bright area ‡¶ï‡¶Æ‡ßá ‚Äì ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ image ‡¶¨‡ßá‡¶∂‡¶ø balanced ‡¶¶‡ßá‡¶ñ‡¶æ‡ßü‡•§

‡¶è‡¶ü‡¶æ RGB image-‡¶è ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø?
‚Üí ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å, ‡¶§‡¶¨‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø color channel (R, G, B) ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶∞‡ßá process ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡ßü‡•§


clc;
clear;
% === Log transformation  of an image WITHOUT Built-in Arithmetic ====
% Step 1: Read the image
img = imread('img3.jpg'); % RGB image

% Step 2: Manually convert to grayscale
[rows, cols, ch] = size(img);
gray_img = zeros(rows, cols);   % Empty grayscale image

for i = 1:rows
    for j = 1:cols
        R = img(i,j,1);
        G = img(i,j,2);
        B = img(i,j,3);
        gray_img(i,j) = 0.2989*R + 0.5870*G + 0.1140*B;
    end
end

% Step 3: Apply log transformation manually
log_img = zeros(rows, cols);     % Empty image for log transform

max_val = max(gray_img(:));      % Maximum grayscale intensity
c = 255 / log(1 + max_val);      % Scaling constant

%‡¶è‡¶á ‡¶≤‡¶æ‡¶á‡¶®‡¶ü‡¶ø scaling constant c ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá, 
% ‡¶Ø‡¶æ‡¶§‡ßá log transform ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞ pixel value-‡¶ó‡ßÅ‡¶≤‡ßã 0 ‡¶•‡ßá‡¶ï‡ßá 255 ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶•‡¶æ‡¶ï‡ßá‡•§

for i = 1:rows
    for j = 1:cols
        log_img(i,j) = c * log(1 + gray_img(i,j));   % Manual log transform
        
        %Log function ‡¶è‡¶∞ output ‡¶Ö‡¶®‡ßá‡¶ï ‡¶∏‡¶Æ‡ßü 255 ‡¶è‡¶∞ ‡¶®‡¶ø‡¶ö‡ßá ‡¶¨‡¶æ ‡¶ì‡¶™‡¶∞‡ßá ‡¶ö‡¶≤‡ßá ‡¶Ø‡¶æ‡ßü, 
        % ‡¶§‡¶æ‡¶á ‡¶Ü‡¶Æ‡¶∞‡¶æ result ‡¶ï‡ßá normalize ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø c ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶ø‡•§

    end
end

% Step 4: Convert to uint8
gray_img = uint8(gray_img);
log_img = uint8(log_img);

% Step 5: Display results manually
figure;
subplot(1,2,1);
imshow(gray_img)
%image(gray_img);
%colormap(gray(256));
axis off;
title('Original Grayscale Image');

subplot(1,2,2);
imshow(log_img)
%image(log_img);
%colormap(gray(256));
axis off;
title('Log Transformed Image');


clc;
clear;

% === Power log transformation(Gamma transformation) 
% of an image WITHOUT Built-in Arithmetic ====

% 1. Input Image (Grayscale matrix manually)
% ‡¶∏‡¶æ‡¶¶‡¶æ ‡¶ï‡¶æ‡¶≤‡ßã ‡¶õ‡¶¨‡¶ø ‡¶®‡¶ø‡¶≤‡¶æ‡¶Æ‡•§ ‡¶ï‡¶æ‡¶≤‡¶æ‡¶∞ ‡¶®‡¶ø‡¶≤‡ßá ‡¶ó‡ßç‡¶∞‡ßá‡¶§‡ßá ‡¶ï‡¶®‡¶≠‡¶æ‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§
% ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá‡¶ì ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá , ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

img = imread('img5.jpg');
[row, col] = size(img); % Image ‡¶è‡¶∞ row ‡¶Ü‡¶∞ column ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ

% 2.pixel value ‡¶ï‡ßá 0-1 scale ‡¶è ‡¶Ü‡¶®‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá

norm_img = double(img) / 255;  

% Power Law apply ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø 
% float number ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡ßü, ‡¶§‡¶æ‡¶á double ‡¶è convert ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§‡¶æ

% 3. Apply Power Law Transformation
%gamma = 0.4; %dark pixel ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶¨‡¶æ‡ßú‡ßá ‚Üí image ‡¶â‡¶ú‡ßç‡¶ú‡ßç‡¶¨‡¶≤ ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡ßü. <1
gamma=1.5; %bright pixel ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶ï‡¶Æ‡ßá ‚Üí image dark ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡ßü >1
output_img = zeros(row, col);  % output image initialize ‡¶ï‡¶∞‡¶æ

for i = 1:row
    for j = 1:col
        output_img(i,j) = norm_img(i,j) ^ gamma;
    end
end

% 4. Convert back to 0-255
%‡¶ï‡¶æ‡¶∞‡¶£ ‡¶õ‡¶¨‡¶ø‡¶∞ pixel value ‡¶Ü‡¶¨‡¶æ‡¶∞ image ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø 0-255 ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ü‡¶®‡¶§‡ßá ‡¶π‡ßü‡•§

output_img = uint8(output_img * 255);

% 5. Show images
figure;
subplot(1,2,1);
imshow(img);
title('Original Image');

subplot(1,2,2);
imshow(output_img);
title(['Power Law Enhanced (Gamma = ', num2str(gamma), ')']);

clc; 
clear;

% Step 1: Define original image (5x5)
img = [100 100 100 100 100;
       100 150 150 150 100;
       100 150 200 150 100;
       100 150 150 150 100;
       100 100 100 100 100];

% Step 2: Define sharpening kernel (3x3)
kernel = [ 0 -1  0;
          -1  5 -1;
           0 -1  0];

% Step 3: Get the size of the image and kernel
[m, n] = size(img);
[km, kn] = size(kernel);

% Step 4: Pad the original image to handle borders (1-pixel padding)
% Step 4: Pad the image with zero

pad_size = floor(km / 2);
padded_img = zeros(m + 2*pad_size, n + 2*pad_size);

% Copy the original image into the center of padded image
for i = 1:m
    for j = 1:n
        padded_img(i + pad_size, j + pad_size) = img(i, j);
    end
end

% Step 5: Create an output image matrix
sharpened_img = zeros(m, n);

%‡ßá‡¶π‡ßá‡¶§‡ßÅ padding-‡¶è‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£‡ßá padded_img ‡¶è‡¶∞ shape ‡¶¨‡¶°‡¶º, ‡¶§‡¶æ‡¶á ‡¶Æ‡ßÇ‡¶≤ image-‡¶è‡¶∞ ‡¶™ ‡ßç‡¶∏‡ßá‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã kernel ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá align ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶á 
% offset (a-1, b-1) ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§

% Step 6: Perform convolution (manually)
for i = 1:m
    for j = 1:n
        sum = 0;
        for a = 1:km
            for b = 1:kn
                x = i + a - 1;
                y = j + b - 1;
                sum = sum + kernel(a, b) * padded_img(x, y);
            end
        end
        sharpened_img(i, j) = sum;
    end
end

% Step 7: Clamp values (0 to 255) for display
sharpened_img = uint8(min(max(sharpened_img, 0), 255));
img = uint8(img);

% Step 8: Show results
fprintf('Original Image:\n');
disp(img);

fprintf('Sharpened Image:\n');
disp(sharpened_img);

figure;
subplot(1,2,1); imshow(img); title('Original Image');
subplot(1,2,2); imshow(sharpened_img); title('Sharpened Image');

%%Using builtin function

%%img = imread('img3.jpg');
%%gray_img = rgb2gray(img);  % RGB ‚Üí Grayscale
%%kernel = [0 -1 0; -1 5 -1; 0 -1 0];
%%sharpened = conv2(double(gray_img), kernel, 'same');
%%imshow(uint8(sharpened));


clc;
clear;

% Step 1: Read a grayscale image
I = imread('cameraman.tif'); % Make sure it's 8-bit grayscale
I = double(I); % Convert to double for bitwise operation

% Step 2: Initialize 8 bit planes
[m, n] = size(I);
bit_planes = zeros(m, n, 8); % 3D array: height x width x 8 planes

% Step 3: Loop through each bit plane
for k = 1:8
    for i = 1:m
        for j = 1:n
            pixel = I(i, j);
            % Extract k-th bit: binary shift and mod
            bit = mod(floor(pixel / 2^(k - 1)), 2);
            bit_planes(i, j, k) = bit * 255; % Multiply by 255 to visualize
        end
    end
end

% Step 4: Show all bit planes
figure;
for k = 1:8
    subplot(2, 4, k);
    imshow(uint8(bit_planes(:, :, 9-k))); % show MSB leftmost
    title(['Bit Plane ', num2str(9-k)]);
end



clc;
clear;

% Step 1: Load grayscale image
%I = imread('cameraman.tif');% ‡¶Ø‡¶¶‡¶ø ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡ßá, ‡¶Ö‡¶®‡ßç‡¶Ø grayscale ‡¶®‡¶æ‡¶ì
I=imread('img3.jpg');
I=0.2989*I(:,:,1) + 0.5870*I(:,:,2) + 0.1140*I(:,:,3);
I = double(I);  % ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßã

[m, n] = size(I);

% Step 2: Define Point Detection Kernel (Laplacian)
point_kernel = [0 -1 0; -1 4 -1; 0 -1 0];

% Step 3: Define Line Detection Kernels
line_horizontal = [-1 -1 -1; 2 2 2; -1 -1 -1];
line_vertical   = [-1 2 -1; -1 2 -1; -1 2 -1];

% Step 4: Padding image (to handle borders)
pad_size = 1;
padded_img = zeros(m + 2*pad_size, n + 2*pad_size);
padded_img(2:end-1, 2:end-1) = I;

% Step 5: Initialize result images
point_img = zeros(m, n);
line_h_img = zeros(m, n);
line_v_img = zeros(m, n);

% Step 6: Convolution manually
for i = 2 : m+1
    for j = 2 : n+1
        region = padded_img(i-1:i+1, j-1:j+1);
        
        % Point detection
        value1 = sum(sum(region .* point_kernel));
        point_img(i-1, j-1) = value1;

        % Horizontal line detection
        value2 = sum(sum(region .* line_horizontal));
        line_h_img(i-1, j-1) = value2;

        % Vertical line detection
        value3 = sum(sum(region .* line_vertical));
        line_v_img(i-1, j-1) = value3;
    end
end

% Step 7: Display the results
subplot(2,2,1); imshow(uint8(I)); title('Original Image');
subplot(2,2,2); imshow(uint8(abs(point_img))); title('Point Detection');
subplot(2,2,3); imshow(uint8(abs(line_h_img))); title('Horizontal Lines');
subplot(2,2,4); imshow(uint8(abs(line_v_img))); title('Vertical Lines');



clc;
clear;
close all;

% Read the image
image = imread('IMG-20220420-WA0000.jpg'); % Replace with your image file

% Convert to grayscale if it's a color image
if size(image, 3) == 3
    image = rgb2gray(image);
end

% Get the size of the image
[m, n] = size(image);

% Define a 3x3 averaging filter
filter = ones(3, 3) / 9;  

% Initialize output image
smoothed_image = zeros(m, n);

% Apply the filter manually
for i = 2:m-1
    for j = 2:n-1
        % Extract the 3x3 region
        region = double(image(i-1:i+1, j-1:j+1));
        
        % Perform element-wise multiplication and sum
        smoothed_value = sum(sum(region .* filter));
        
        % Assign new value to the output image
        smoothed_image(i, j) = smoothed_value;
    end
end

% Convert back to uint8
smoothed_image = uint8(smoothed_image);

% Display the results
figure;
subplot(1,2,1);
imshow(image);
title('Original Image');

subplot(1,2,2);
imshow(smoothed_image);
title('Smoothed¬†Image');


********python*****************
# -*- coding: utf-8 -*-
"""dip.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bn8BemQdYpZdVr_y3mo5Wh6t57vERwfY
"""

#Task 1: Load and Preprocess Image

#These lines import the necessary libraries:
#cv2 is OpenCV, used for image processing.
#numpy (imported as np) is used for numerical operations, often with arrays.
#matplotlib.pyplot (as plt) is used for plotting and displaying images or graphs.

#This line loads an image file named 'your_image.jpg' in grayscale mode (black and white).
#cv2.IMREAD_GRAYSCALE tells OpenCV to ignore color and just load intensity values (0 to 255).

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image in grayscale
image = cv2.imread('dip.jpg', cv2.IMREAD_GRAYSCALE)

# Resize the image to 256x256 for simplicity
image = cv2.resize(image, (256, 256))

# Display the original image
plt.imshow(image, cmap='gray')
plt.title('Original Grayscale Image')
plt.axis('off')
plt.show()

#Task 2: Apply Fourier Transform and Show the Fourier Spectrum

#Steps:
#Use np.fft.fft2 to compute the 2D Fourier Transform.
#Shift the zero-frequency component to the center using np.fft.fftshift.

#Explanation:
#The Fourier Transform converts the image from the spatial domain to the frequency domain.
#The magnitude spectrum shows the frequency content: bright spots represent dominant frequencies.

# Compute the 2D Fourier Transform
f_transform = np.fft.fft2(image)
f_shift = np.fft.fftshift(f_transform)

# Compute the magnitude spectrum (log scale for visualization)

#np.abs(f_shift) gives the magnitude (ignoring phase) of the complex Fourier values.
#We add +1 to avoid taking log of 0.
#Multiplying by 20 scales the values for better visibility (this is common in signal processing).
#This gives a more viewable magnitude spectrum, highlighting the strength of various frequency components.

magnitude_spectrum = 20 * np.log(np.abs(f_shift) + 1)

# Display the Fourier spectrum
plt.imshow(magnitude_spectrum, cmap='gray')
plt.title('Fourier Spectrum')
plt.axis('off')
plt.show()

#Task 3: Implement Frequency Domain Filters

#(A) Notch Filter

#A notch filter removes specific frequencies (e.g., to remove periodic noise).

# Dimensions of the image

#Gets the dimensions of the image.
#Calculates the center coordinates (crow, ccol) of the image ‚Äî this is where the low frequencies are located after the fftshift

rows, cols = image.shape
crow, ccol = rows // 2, cols // 2

#Creates a notch filter ‚Äî a mask that allows most frequencies to pass except a small region at the center.
#notch_filter is initialized to all ones (i.e., let all frequencies pass).
#A square of zeros is set at the center to block low frequencies in a 20√ó20 area (10 pixels in all directions).
#This filter suppresses a small region in the frequency spectrum (often useful for removing periodic noise or unwanted patterns).

# Create a notch filter (block a specific frequency)
notch_filter = np.ones((rows, cols), np.float32)
notch_radius = 10
notch_filter[crow-notch_radius:crow+notch_radius, ccol-notch_radius:ccol+notch_radius] = 0

# Apply the notch filter
#Multiplies the shifted Fourier spectrum with the notch filter.
#Effectively removes (zeroes out) the blocked frequencies.
f_shift_notch = f_shift * notch_filter

# Inverse Fourier Transform
#ifftshift reverts the shift done earlier to prepare for inverse FFT.
#ifft2 performs the Inverse Fourier Transform, converting the image back to the spatial domain.

f_ishift_notch = np.fft.ifftshift(f_shift_notch)
img_notch = np.fft.ifft2(f_ishift_notch)
img_notch = np.abs(img_notch)

# Display the result
plt.imshow(img_notch, cmap='gray')
plt.title('Notch Filter Result')
plt.axis('off')
plt.show()

#Notch Filter:
#Removes specific frequencies. If your image has periodic noise (e.g., horizontal/vertical lines),
#the notch filter will suppress those patterns. The image may look cleaner but might lose some details if the notched frequency corresponds to important features.

#Low-pass Filter:

#Ideal: Blurs the image by removing high-frequency components (edges/details). It can cause ringing artifacts due to its sharp cutoff.
#Gaussian: Also blurs the image but with a smoother transition, avoiding ringing artifacts. The image appears more naturally blurred.

# Radius for the low-pass filter
D0 = 30  # Cutoff frequency

# Ideal Low-pass Filter
lowpass_ideal = np.zeros((rows, cols), np.float32)
for i in range(rows):
    for j in range(cols):
      #is used to calculate the distance between two points in a 2D plane ‚Äî specifically:
      #The distance from point(i,j) to the center point (ùëêùëüùëúùë§,ùëêùëêùëúùëô)(crow,ccol) of the image.
        D = np.sqrt((i - crow)**2 + (j - ccol)**2)
        if D <= D0:
            lowpass_ideal[i, j] = 1

            #Creates an Ideal Low-Pass Filter: a sharp circular mask that passes only frequencies inside radius D0.
            #Pixels outside this circle are 0 (blocked); inside are 1 (passed).
            #This produces a clear cutoff, but can cause artifacts like ringing in the output image.

# Gaussian Low-pass Filter
lowpass_gaussian = np.zeros((rows, cols), np.float32)
for i in range(rows):
    for j in range(cols):
        D = np.sqrt((i - crow)**2 + (j - ccol)**2)
        lowpass_gaussian[i, j] = np.exp(-(D**2) / (2 * (D0**2)))

        #Creates a Gaussian Low-Pass Filter: a smooth circular mask with a gradual fall-off.
        #Values decrease smoothly from 1 at the center to near 0 at the edges.
        #It‚Äôs softer and avoids artifacts, making it visually more natural.

# Apply the filters
f_shift_lowpass_ideal = f_shift * lowpass_ideal
f_shift_lowpass_gaussian = f_shift * lowpass_gaussian

# Inverse Fourier Transform for both
f_ishift_lowpass_ideal = np.fft.ifftshift(f_shift_lowpass_ideal)
img_lowpass_ideal = np.abs(np.fft.ifft2(f_ishift_lowpass_ideal))

f_ishift_lowpass_gaussian = np.fft.ifftshift(f_shift_lowpass_gaussian)
img_lowpass_gaussian = np.abs(np.fft.ifft2(f_ishift_lowpass_gaussian))

# Display the results
plt.subplot(121), plt.imshow(img_lowpass_ideal, cmap='gray'), plt.title('Ideal Low-pass')
plt.axis('off')
plt.subplot(122), plt.imshow(img_lowpass_gaussian, cmap='gray'), plt.title('Gaussian Low-pass')
plt.axis('off')
plt.show()

#High-pass Filter:

#Ideal: Enhances edges and details by removing low frequencies. The image looks like an edge map, with smooth areas darkened.
#Gaussian: Similar to the ideal high-pass but with a smoother transition, resulting in less harsh edge enhancement.

# Ideal High-pass Filter (1 - Low-pass)
highpass_ideal = 1 - lowpass_ideal

# Gaussian High-pass Filter (1 - Gaussian Low-pass)
highpass_gaussian = 1 - lowpass_gaussian

# Apply the filters
f_shift_highpass_ideal = f_shift * highpass_ideal
f_shift_highpass_gaussian = f_shift * highpass_gaussian

# Inverse Fourier Transform for both
f_ishift_highpass_ideal = np.fft.ifftshift(f_shift_highpass_ideal)
img_highpass_ideal = np.abs(np.fft.ifft2(f_ishift_highpass_ideal))

f_ishift_highpass_gaussian = np.fft.ifftshift(f_shift_highpass_gaussian)
img_highpass_gaussian = np.abs(np.fft.ifft2(f_ishift_highpass_gaussian))

# Display the results
plt.subplot(121), plt.imshow(img_highpass_ideal, cmap='gray'), plt.title('Ideal High-pass')
plt.axis('off')
plt.subplot(122), plt.imshow(img_highpass_gaussian, cmap='gray'), plt.title('Gaussian High-pass')
plt.axis('off')
plt.show()