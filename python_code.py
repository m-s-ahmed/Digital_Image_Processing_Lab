# -*- coding: utf-8 -*-
"""dip.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bn8BemQdYpZdVr_y3mo5Wh6t57vERwfY
"""

#Task 1: Load and Preprocess Image

#These lines import the necessary libraries:
#cv2 is OpenCV, used for image processing.
#numpy (imported as np) is used for numerical operations, often with arrays.
#matplotlib.pyplot (as plt) is used for plotting and displaying images or graphs.

#This line loads an image file named 'your_image.jpg' in grayscale mode (black and white).
#cv2.IMREAD_GRAYSCALE tells OpenCV to ignore color and just load intensity values (0 to 255).

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image in grayscale
image = cv2.imread('dip.jpg', cv2.IMREAD_GRAYSCALE)

# Resize the image to 256x256 for simplicity
image = cv2.resize(image, (256, 256))

# Display the original image
plt.imshow(image, cmap='gray')
plt.title('Original Grayscale Image')
plt.axis('off')
plt.show()

#Task 2: Apply Fourier Transform and Show the Fourier Spectrum

#Steps:
#Use np.fft.fft2 to compute the 2D Fourier Transform.
#Shift the zero-frequency component to the center using np.fft.fftshift.

#Explanation:
#The Fourier Transform converts the image from the spatial domain to the frequency domain.
#The magnitude spectrum shows the frequency content: bright spots represent dominant frequencies.

# Compute the 2D Fourier Transform
f_transform = np.fft.fft2(image)
f_shift = np.fft.fftshift(f_transform)

# Compute the magnitude spectrum (log scale for visualization)

#np.abs(f_shift) gives the magnitude (ignoring phase) of the complex Fourier values.
#We add +1 to avoid taking log of 0.
#Multiplying by 20 scales the values for better visibility (this is common in signal processing).
#This gives a more viewable magnitude spectrum, highlighting the strength of various frequency components.

magnitude_spectrum = 20 * np.log(np.abs(f_shift) + 1)

# Display the Fourier spectrum
plt.imshow(magnitude_spectrum, cmap='gray')
plt.title('Fourier Spectrum')
plt.axis('off')
plt.show()

#Task 3: Implement Frequency Domain Filters

#(A) Notch Filter

#A notch filter removes specific frequencies (e.g., to remove periodic noise).

# Dimensions of the image

#Gets the dimensions of the image.
#Calculates the center coordinates (crow, ccol) of the image ‚Äî this is where the low frequencies are located after the fftshift

rows, cols = image.shape
crow, ccol = rows // 2, cols // 2

#Creates a notch filter ‚Äî a mask that allows most frequencies to pass except a small region at the center.
#notch_filter is initialized to all ones (i.e., let all frequencies pass).
#A square of zeros is set at the center to block low frequencies in a 20√ó20 area (10 pixels in all directions).
#This filter suppresses a small region in the frequency spectrum (often useful for removing periodic noise or unwanted patterns).

# Create a notch filter (block a specific frequency)
notch_filter = np.ones((rows, cols), np.float32)
notch_radius = 10
notch_filter[crow-notch_radius:crow+notch_radius, ccol-notch_radius:ccol+notch_radius] = 0

# Apply the notch filter
#Multiplies the shifted Fourier spectrum with the notch filter.
#Effectively removes (zeroes out) the blocked frequencies.
f_shift_notch = f_shift * notch_filter

# Inverse Fourier Transform
#ifftshift reverts the shift done earlier to prepare for inverse FFT.
#ifft2 performs the Inverse Fourier Transform, converting the image back to the spatial domain.

f_ishift_notch = np.fft.ifftshift(f_shift_notch)
img_notch = np.fft.ifft2(f_ishift_notch)
img_notch = np.abs(img_notch)

# Display the result
plt.imshow(img_notch, cmap='gray')
plt.title('Notch Filter Result')
plt.axis('off')
plt.show()

#Notch Filter:
#Removes specific frequencies. If your image has periodic noise (e.g., horizontal/vertical lines),
#the notch filter will suppress those patterns. The image may look cleaner but might lose some details if the notched frequency corresponds to important features.

#Low-pass Filter:

#Ideal: Blurs the image by removing high-frequency components (edges/details). It can cause ringing artifacts due to its sharp cutoff.
#Gaussian: Also blurs the image but with a smoother transition, avoiding ringing artifacts. The image appears more naturally blurred.

# Radius for the low-pass filter
D0 = 30  # Cutoff frequency

# Ideal Low-pass Filter
lowpass_ideal = np.zeros((rows, cols), np.float32)
for i in range(rows):
    for j in range(cols):
      #is used to calculate the distance between two points in a 2D plane ‚Äî specifically:
      #The distance from point(i,j) to the center point (ùëêùëüùëúùë§,ùëêùëêùëúùëô)(crow,ccol) of the image.
        D = np.sqrt((i - crow)**2 + (j - ccol)**2)
        if D <= D0:
            lowpass_ideal[i, j] = 1

            #Creates an Ideal Low-Pass Filter: a sharp circular mask that passes only frequencies inside radius D0.
            #Pixels outside this circle are 0 (blocked); inside are 1 (passed).
            #This produces a clear cutoff, but can cause artifacts like ringing in the output image.

# Gaussian Low-pass Filter
lowpass_gaussian = np.zeros((rows, cols), np.float32)
for i in range(rows):
    for j in range(cols):
        D = np.sqrt((i - crow)**2 + (j - ccol)**2)
        lowpass_gaussian[i, j] = np.exp(-(D**2) / (2 * (D0**2)))

        #Creates a Gaussian Low-Pass Filter: a smooth circular mask with a gradual fall-off.
        #Values decrease smoothly from 1 at the center to near 0 at the edges.
        #It‚Äôs softer and avoids artifacts, making it visually more natural.

# Apply the filters
f_shift_lowpass_ideal = f_shift * lowpass_ideal
f_shift_lowpass_gaussian = f_shift * lowpass_gaussian

# Inverse Fourier Transform for both
f_ishift_lowpass_ideal = np.fft.ifftshift(f_shift_lowpass_ideal)
img_lowpass_ideal = np.abs(np.fft.ifft2(f_ishift_lowpass_ideal))

f_ishift_lowpass_gaussian = np.fft.ifftshift(f_shift_lowpass_gaussian)
img_lowpass_gaussian = np.abs(np.fft.ifft2(f_ishift_lowpass_gaussian))

# Display the results
plt.subplot(121), plt.imshow(img_lowpass_ideal, cmap='gray'), plt.title('Ideal Low-pass')
plt.axis('off')
plt.subplot(122), plt.imshow(img_lowpass_gaussian, cmap='gray'), plt.title('Gaussian Low-pass')
plt.axis('off')
plt.show()

#High-pass Filter:

#Ideal: Enhances edges and details by removing low frequencies. The image looks like an edge map, with smooth areas darkened.
#Gaussian: Similar to the ideal high-pass but with a smoother transition, resulting in less harsh edge enhancement.

# Ideal High-pass Filter (1 - Low-pass)
highpass_ideal = 1 - lowpass_ideal

# Gaussian High-pass Filter (1 - Gaussian Low-pass)
highpass_gaussian = 1 - lowpass_gaussian

# Apply the filters
f_shift_highpass_ideal = f_shift * highpass_ideal
f_shift_highpass_gaussian = f_shift * highpass_gaussian

# Inverse Fourier Transform for both
f_ishift_highpass_ideal = np.fft.ifftshift(f_shift_highpass_ideal)
img_highpass_ideal = np.abs(np.fft.ifft2(f_ishift_highpass_ideal))

f_ishift_highpass_gaussian = np.fft.ifftshift(f_shift_highpass_gaussian)
img_highpass_gaussian = np.abs(np.fft.ifft2(f_ishift_highpass_gaussian))

# Display the results
plt.subplot(121), plt.imshow(img_highpass_ideal, cmap='gray'), plt.title('Ideal High-pass')
plt.axis('off')
plt.subplot(122), plt.imshow(img_highpass_gaussian, cmap='gray'), plt.title('Gaussian High-pass')
plt.axis('off')
plt.show()